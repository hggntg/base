import mongoose from "mongoose";
import { getForeignField, BASE_ENTITY_SERVICE } from "../../../main/entity";
import { IBaseEntity, ICollection, IDocumentChange } from "../../../interface";
import { getCollectionMetadata } from "./decorator";
import { getDbContextMetadata } from "../decorator";
import { Injectable, getDependency } from "@base/class";


function toSinglePromise<K, T>(classImp: { new(): T }, fn: mongoose.DocumentQuery<mongoose.Document, mongoose.Document>) {
	return new Promise<Partial<K>>((resolve, reject) => {
		let query = (fn as mongoose.DocumentQuery<mongoose.Document, mongoose.Document>);
		let foreignFields = getForeignField(classImp);
		let removedFields = [];
		foreignFields.map(foreignField => {
			if(foreignField.load === "eager"){
				query.populate(foreignField.name);
			}
			removedFields.push(foreignField.localField);
		});
		query.then(res => {
			if(res){
				let document = res.toObject();
				if (document._id) {
					document.id = document._id;
				}
				removedFields.map((removedField) => {
					delete document[removedField];
				});
				document = removeMongooseField(document);
				resolve(document as Partial<K>);	
			}
			else{
				resolve(null);
			}
		}).catch(err => {
			reject(err);
		})
	});
}

function toListPromise<K, T>(classImp: { new(): T }, type: "query", fn: mongoose.DocumentQuery<mongoose.Document[], mongoose.Document>);
function toListPromise<K, T>(classImp: { new(): T }, type: "aggregate", fn: mongoose.Aggregate<any[]>);
function toListPromise<K, T>(classImp: { new(): T }, type: "query" | "aggregate", fn: mongoose.DocumentQuery<mongoose.Document[], mongoose.Document> | mongoose.Aggregate<any[]>) {
	return new Promise<Partial<K>[]>((resolve, reject) => {
		if (type === "query") {
			let query = (fn as mongoose.DocumentQuery<mongoose.Document[], mongoose.Document>);
			let foreignFields = getForeignField(classImp);
			let removedFields = [];
			foreignFields.map(foreignField => {
				if(foreignField.load === "eager"){
					query.populate(foreignField.name);
				}
				removedFields.push(foreignField.localField);
			});
			query.then(res => {
				let documents = [];
				res.map(r => {
					let document = r.toObject();
					if (document._id) {
						document.id = document._id;
					}
					removedFields.map((removedField) => {
						delete document[removedField];
					});
					document = removeMongooseField(document);
					documents.push(document);
				});
				resolve(documents as Partial<K>[]);
			}).catch(err => {
				reject(err);
			});
		}
		else {
			(fn as mongoose.Aggregate<any[]>).then(res => {
				let documents = [];
				res.map(r => {
					if (r._id) {
						r.id = r._id;
						delete r._id;
					}
					documents.push(r);
				});
				resolve(documents as Partial<K>[]);
			}).catch(err => {
				reject(err);
			});
		}
	});
}

function removeMongooseField(doc){
	let cloneDoc = Object.assign({}, doc);
	delete cloneDoc._id;
	delete cloneDoc.__v;
	let docKeys = Object.keys(cloneDoc);
	let docKeyLength = docKeys.length;
	for(let i = 0; i < docKeyLength; i++){
		let key = docKeys[i];
		if(typeof cloneDoc[key] === "object" && !(cloneDoc[key] instanceof mongoose.Types.ObjectId)){
			cloneDoc[key] = removeMongooseField(cloneDoc[key]);
		}
	}
	return cloneDoc;
}

function removeId(doc) {
	let cloneDoc = Object.assign({}, doc);
	if(cloneDoc.id){
        cloneDoc._id = cloneDoc.id;
        delete cloneDoc.id;
    }
	let docKeys = Object.keys(cloneDoc);
	let docKeyLength = docKeys.length;
	for(let i = 0; i < docKeyLength; i++){
		let key = docKeys[i];
		if(typeof cloneDoc[key] === "object" && !(cloneDoc[key] instanceof mongoose.Types.ObjectId)){
			cloneDoc[key] = removeId(cloneDoc[key]);
		}
	}
	return cloneDoc;
}

export const COLLECTION_SERVICE = "ICollection";

@Injectable(COLLECTION_SERVICE, true, true)
export class Collection<K, T extends IBaseEntity<K>> implements ICollection<K, T>{
	getType(): IClassType {
		throw new Error("Method not implemented.");
	}
	aggregate(conditions: any[]): Promise<Partial<K>[]> {
		conditions = removeId(conditions);
		return toListPromise<K, T>(this.classImp, "aggregate", this.model.aggregate(conditions));
	}
	find(conditions: any = {}) {
		conditions = removeId(conditions);
		return toListPromise<K, T>(this.classImp, "query", this.model.find(conditions));
	}
	findOne(conditions: any = {}) {
		conditions = removeId(conditions);
		return toSinglePromise<K, T>(this.classImp, this.model.findOne(conditions));
	}
	findById(_id: string) {
		if (this.validObjectId([_id])) {
			return toSinglePromise<K, T>(this.classImp, this.model.findById(_id));
		}
		else {
			throw new Error("_id is not an ObjectId");
		}
	}
	findByIds(_ids: Array<string>) {
		if (this.validObjectId(_ids)) {
			let conditions: {
				_id: {
					$in: Array<mongoose.Types.ObjectId>
				}
			} = {
				_id: {
					$in: new Array()
				}
			};
			_ids.map(_id => {
				conditions._id.$in.push(mongoose.Types.ObjectId(_id));
			});
			return this.find(conditions);
		}
		else {
			throw new Error("_id is not an ObjectId");
		}
	}
	insert(doc: Partial<K>) {
		doc = removeId(doc);
		return new Promise<Partial<K>>((resolve, reject) => {
			try {
				let model = this.model;
				let document = new model(doc);
				this.setChanges("INSERT", document);
				resolve(document.toObject() as Partial<K>);
			}
			catch (e) {
				reject(e);
			}
		});
	}
	insertMany(docs: Array<Partial<K>>) {
		docs = docs.map(doc => {
			return removeId(doc);
		})
		return new Promise<Partial<K>[]>((resolve, reject) => {
			try {
				let model = this.model;
				let documents = [];
				docs.map((doc, index) => {
					let document = new model(doc);
					this.setChanges("INSERT", document);
					documents.push(document.toObject() as Partial<K>);
				});
				resolve(documents as Partial<K>[]);
			}
			catch (e) {
				reject(e);
			}
		});
	}
	remove(conditions: any = {}) {
		conditions = removeId(conditions);
		let model = this.model;
		return this.find(conditions).then(docs => {
			docs.map(doc => {
				let document = new model(removeId(doc));
				document.isNew = false;
				this.setChanges("REMOVE", document);
			});
			return docs as Partial<K>[];
		});
	}
	removeById(_id: string) {
		let model = this.model;
		return this.findById(_id).then(doc => {
			let document = new model(removeId(doc));
			document.isNew = false;
			this.setChanges("REMOVE", document);
			return doc as Partial<K>;
		});
	}
	removeMany(_ids: Array<string>) {
		let model = this.model;
		return this.findByIds(_ids).then(docs => {
			docs.map(doc => {
				let document = new model(removeId(doc));
				document.isNew = false;
				this.setChanges("REMOVE", document);
			});
			return docs as Partial<K>[];
		});
	}
	update(conditions: any, data: any) {
		conditions = removeId(conditions);
		let model = this.model;
		return this.find(conditions).then(docs => {
			let documents: Partial<K>[] = [];
			docs.map(doc => {
				let document = new model(removeId(doc));
				document.isNew = false;
				this.setChanges("UPDATE", document, data);
				let tempDocument = new model(removeId(doc));
				tempDocument.isNew = false;
				tempDocument.set(data);
				let returnDocument = tempDocument.toObject();
				returnDocument.id = returnDocument._id;
				delete returnDocument._id;
				documents.push(returnDocument as Partial<K>);
			});
			return documents;
		});
	}
	updateById(_id: string, data: any) {
		let model = this.model;
		return this.findById(_id).then(doc => {
			let document = new model(removeId(doc));
			document.isNew = false;
			this.setChanges("UPDATE", document, data);
			let tempDocument = new model(removeId(doc));
			tempDocument.isNew = false;
			tempDocument.set(data);
			let returnDocument = tempDocument.toObject();
			returnDocument.id = returnDocument._id;
			delete returnDocument._id;
			return returnDocument as Partial<K>;
		});
	}
	updateMany(_ids: Array<string>, data: any) {
		let model = this.model;
		return this.findByIds(_ids).then(docs => {
			let documents: Partial<K>[] = [];
			docs.map(doc => {
				let document = new model(removeId(doc));
				document.isNew = false;
				this.setChanges("UPDATE", document, data);
				let tempDocument = new model(removeId(doc));
				tempDocument.isNew = false;
				tempDocument.set(data);
				let returnDocument = tempDocument.toObject();
				returnDocument.id = returnDocument._id;
				delete returnDocument._id;
				documents.push(returnDocument as Partial<K>);
			});
			return documents;
		});
	}
	count() {
		return this.model.countDocuments();
	}
	private validObjectId(_ids: Array<string>) {
		let isValid = 1;
		_ids.map(_id => {
			if (mongoose.Types.ObjectId.isValid(_id)) {
				isValid *= 1;
			}
			else {
				isValid *= 0;
			}
		})
		return isValid ? true : false;
	}
	private setChanges(type: "REMOVE" | "INSERT" | "UPDATE", document: mongoose.Document, data?: any) {
		let namespace = this.dbContext.context;
		if (namespace) {
			let session = namespace.get<Promise<mongoose.ClientSession>>("session");
			if (!session) {
				session = this.connection.startSession();
				namespace.set("session", session);
			}
			let documents = namespace.get<IDocumentChange[]>("documents") || [];
			documents.push({ type: type, document: document, data: data });
			namespace.set("documents", documents);
		}
		else {
			throw new Error("DbContext change detector not exists");
		}
	}
	get model() {
		return this.entity.getInstance();
	}
	get connection() {
		return this.dbContext.connection;
	}
	get dbContext() {
		let collectionMetadata = getCollectionMetadata(this.classImp);
		let dbContextMetadata = getDbContextMetadata(collectionMetadata.dbContextClass);
		return dbContextMetadata;
	}
	private entity: IBaseEntity;
	private classImp: { new(): T };

	initValue(input: Partial<{ classImp: { new(): T } }>) {
		this.entity = getDependency<IBaseEntity>(BASE_ENTITY_SERVICE, input.classImp.name);
		this.classImp = input.classImp;
	}
}

export * from "./decorator";